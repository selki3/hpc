table 2 compares the throughput of performing inference and training on the treelstm model using our implementation , the iterative approach , and the folding technique . the amount of resources is sufficient for executing forward computations , and therefore our framework outperforms the folding technique for the inference task with up to 4 . 93x faster throughput . as a result , the folding technique performs better than the recursive approach for the training task .
table 1 shows the throughput of training the treernn model using these three datasets . for all batch sizes , the training throughput on the balanced dataset is the highest , while the throughput on the linear dataset is the lowest . as a result , our implementation can train input data of balanced trees with greater throughput than input data of unbalanced trees . another interesting fact in table 1 is that the training throughput on the linear dataset scales better than the throughput on the balanced dataset , as the batch size increases . on the contrary , for the linear dataset , the recursive implementation fails to efficiently make use of cpu resources and thus the performance gain provided by increasing the batch size is relatively high .
table 2 presents the optimal values for each configuration using different dependency representations . we see that the optimized parameter settings vary for the different representations , showing the importance of tuning for these types of comparisons . the results furthermore show that the sdps based on the stanford basic ( sb ) representation provide the best performance , followed by the conll08 representation . we observe that the results for the ud representation are quite a bit lower than the two others .
we find that the effect of syntactic structure varies between the different relation types . however , the sdp information has a clear positive impact on all the relation types ( table 1 ) .
accordingly , as table 3 shows for the essay level ( paragraph level omitted for space reasons ) , results are generally weaker : as in eq . ( 1 ) — the overall result is worst . we find that when we train stagbl with only its main task — with label set in y contrast , when we include the ' natural subtasks ' " c " ( label performance increases typically by a few percentage points .
we train and test all parsers on the paragraph level , mate is slightly better kiperwasser performs decently on the approximate match level , but not on exact level . the best parser by far is the lstm - parser . it is over 100 % better than kiperwasser on exact spans and still several percentage points on approximate spans . : performance of dependency parsers , stagblcc , lstm - er and ilp ( from top to bottom ) . on the other hand , our results in table 2 indicate that the neural taggers blcc and blc ( in the lstmer model ) are much better at such exact identification than either the ilp model or the neural parsers .
these results detail that the taggers have lower standard deviations than the parsers . the difference is particularly striking on the essay level where the parsers often completely fail to learn , that is , their performance scores are close to 0 % .
the results for testing on cleaned data ( table 3 , top half ) confirm the positive impact of cleaned training data and also show that the cleaned test data is more challenging ( cf . section 3 ) , as reflected in the lower woms . however , the improved results for training and testing on clean data ( i . e . seeing equally challenging examples at training and test time ) , suggest the increase in performance can be attributed to data accuracy rather than diversity . looking at the detailed results for the number of added , missing , and wrong - valued slots ( add , miss , wrong ) , we observe more deletions than insertions , i . e . the models more often fail to realise part of the mr , rather than hallucinating additional information . however , the results in bottom halves of tables 2 and 3 do not support our hypothesis : we observe the main effect on ser from cleaning the missed slots , reducing both insertions and deletions . again , one possible explanation is that cleaning the missing slots provided more complex training examples .
this resulted in 20 % reduction for train and ca . 8 % reduction for dev in terms of references ( see table 1 ) . on the other hand , the number of distinct mrs rose sharply after reannotation ; the mrs also have more variance in the number of attributes . this means that the cleaned dataset is more complex overall , with fewer references per mr and more diverse mrs .
the results in table 2 ( top half ) for the original setup confirm that the ranking mechanism for tgen is effective for both woms and ser , whereas the sc - lstm seems to have trouble scaling to the e2e dataset . we hypothesise that this is mainly due to the amount of delexicalisation required . however , the main improvement of ser comes from training on cleaned data with up to 97 % error reduction with the ranker and 94 % without . 11 just cleaning the training data has a much more dramatic effect than just using a semantic control mechanism , such as the reranker ( 0 . 97 % vs . 4 . 27 % ser ) . woms are slightly lower for tgen trained on the cleaned data , except for nist , which gives more importance to matching less frequent n - grams . this suggests better preservation of content at the expense of slightly lower fluency . in other words , however , the results in bottom halves of tables 2 and 3 do not support our hypothesis : we observe the main effect on ser from cleaning the missed slots , reducing both insertions and deletions . again , one possible explanation is that cleaning the missing slots provided more complex training examples .
the results in table 4 confirm the findings of the automatic metrics : systems trained on the fully cleaned set or the set with cleaned missing slots have nearperfect performance , with the fully - cleaned one showing a few more slight disfluencies than the other . the systems trained on the original data or with cleaned added slots clearly perform worse in terms of both semantic accuracy and fluency . all fluency problems we found were very slight and no added or wrong - valued slots were found , so missed slots are the main problem .
moreover , we compare our dcgcn ( single ) and dcgcn ( ensemble ) model with the state - of - the - art semi - supervised models on the amr15 test set ( table 3 ) , including non - neural methods such as tsp ( song et al . , 2016 ) , pbmt ( pourdamghani et al . , 2016 ) , tree2str ( flanigan et al . , 2016 ) and snrg ( song et al . , 2017 ) . all these non - neural models train language models on the whole gigaword corpus . our ensemble model gives 28 . 2 bleu points without external data , which is better than them . following konstas et al . ( 2017 ) ; song et al . ( 2018 ) , we also evaluate our model using external gigaword sentences as training data . we first use the additional data to pretrain the model , then finetune it on the gold data . using additional 0 . 1m data , the single dcgcn model achieves a bleu score of 29 . 0 , which is higher than seq2seqk ( konstas et al . , 2017 ) and graphlstm ( song et al . , 2018 ) trained with 0 . 2m additional data . when using the same amount of 0 . 2m data , the performance of dcgcn is 4 . 2 and 3 . 4 bleu points higher than seq2seqk and graphlstm . dcgcn model is able to achieve a competitive bleu points ( 33 . 2 ) by using 0 . 3m external data , while graphlstm achieves a score of 33 . 6 by using 2m data and seq2seqk achieves a score of 33 . 8 by using 20m data . these results show that our model is more effective in terms of using automatically generated am
table 2 shows the results on amr17 . our single model achieves 27 . 6 bleu points , which is the new state - of - the - art result for single models . in particular , our single dcgcn model consistently outperforms seq2seq models by a significant margin when trained without external resources . for example , the single dcgcn model gains 5 . 9 more bleu points than the single models of seq2seqb on amr17 . these results demonstrate the importance of explicitly capturing the graph structure in the encoder . in addition , our single dcgcn model obtains better results than previous ensemble models . for example , on amr17 , the single dcgcn model is 1 bleu point higher than the ensemble model of seq2seqb . our model requires substantially fewer parameters , e . g . , the parameter size is only 3 / 5 and 1 / 9 of those in ggnn2seq and seq2seqb , respectively . the ensemble approach based on combining five dcgcn models initialized with different random seeds achieves a bleu score of 30 . 4 and a chrf + + score of 59 . 6 . under the same setting , our model also consistently outperforms graph encoders based on recurrent neural networks or gating mechanisms . for ggnn2seq , our single model is 3 . 3 and 0 . 1 bleu points higher than their single and ensemble models , respectively . we also have similar observations in term of chrf + + scores for sentence - level evaluations . dcgcn also outperforms graphlstm by 2 . 0 bleu points in the fully supervised setting as shown in table 3 . note that graphlstm uses char - level neural represen tations and pretrained word embeddings , while our model solely relies on word -
table 4 shows the results for the englishgerman ( en - de ) and english - czech ( en - cs ) translation tasks . bow + gcn , cnn + gcn and birnn + gcn refer to employing the following encoders with a gcn layer on top respectively : 1 ) a bag - of - words encoder , 2 ) a one - layer cnn , 3 ) a bidirectional rnn . pb - smt is the phrase - based statistical machine translation model using moses ( koehn et al . , 2007 ) . our single model dcgcn ( single ) achieves 19 . 0 and 12 . 1 bleu points on the en - de and encs tasks , respectively , significantly outperforming all the single models . for example , compared to the best gcn - based model ( birnn + gcn ) , our single dcgcn model surpasses it by 2 . 7 and 2 . 5 bleu points on the en - de and en - cs tasks , respectively . our models dcgcn ( single ) and dcgcn ( ensemble ) consist of full gcn layers , removing the burden of employing a recurrent encoder to extract non - local contextual information in the bottom layers . compared to non - gcn models , our single dcgcn model is 2 . 2 and 1 . 9 bleu points higher than the current state - of - theart single model ( ggnn2seq ) on the en - de and en - cs translation tasks , respectively . in addition , our single model is comparable to the ensemble results of seq2seqb and ggnn2seq , while the number of parameters of our models is only about 1 / 6 of theirs . additionally , the ensemble dcgcn models achieve 20 . 5 and 13 . 1 bleu points on the en - de and en
layers in the sub - block . table 5 shows the effect of the number of layers of each sub - block on the amr15 development set . densenets ( huang et al . , 2017 ) use two kinds of convolution filters : 1 × 1 and 3 × 3 . similar to densenets , we choose the values of n and m for layers from [ 1 , 2 , 3 , 6 ] . we choose this value range by considering the scale of non - local nodes , the abstract information at different level and the calculation efficiency . for brevity , we only show representative configurations . we first investigate dcgcn with one block . in general , the performance increases when we gradually enlarge n and m . for example , when n = 1 and m = 1 , the bleu score is 17 . 6 ; when n = 6 and m = 6 , the bleu score becomes 22 . 0 . we observe that the three settings ( n = 6 , m = 3 ) , ( n = 3 , m = 6 ) and ( n = 6 , m = 6 ) give similar results for both 1 dcgcn block and 2 dcgcn blocks . since the first two settings contain less parameters than the third setting , it is reasonable to choose either ( n = 6 , m = 3 ) or ( n = 3 , m = 6 ) . for later experiments , we use ( n = 6 , m = 3 ) .
the first block in table 6 shows the performance of our two baseline models : multi - layer gcns with residual connections ( gcn + rc ) and multi - layer gcns with both residual connections and layer aggregations ( gcn + rc + la ) . in general , increasing the number of gcn layers from 2 to 9 boosts the model performance . however , when the layer number exceeds 10 , the performance of both baseline models start to drop . for example , gcn + rc + la ( 10 ) achieves a bleu score of 21 . 2 , which is worse than gcn + rc + la ( 9 ) . in preliminary experiments , we cannot manage to train very deep gcn + rc and gcn + rc + la models . in contrast , our dcgcn models can be trained using a large number of layers . for example , dcgcn4 contains 36 layers . when we increase the dcgcn blocks from 1 to 4 , the model performance continues increasing on amr15 development set . we therefore choose dcgcn4 for the amr experiments . using a similar method , dcgcn2 is selected for the nmt tasks . when the layer numbers are 9 , dcgcn1 is better than gcn + rc in term of b / c scores ( 21 . 7 / 51 . 5 v . s . 21 . 1 / 50 . 5 ) . gcn + rc + la ( 9 ) is sightly better than dcgcn1 . however , when we set the number to 18 , gcn + rc + la achieves a bleu score of 19 . 4 , which is significantly worse than the bleu score obtained by dcgcn2 ( 23 . 3 ) . we also try gcn + rc + la ( 27 ) , but it does not converge . in conclusion , these results above can show the robustness and effectiveness of our dcgcn models
we compare dcgcn models with different layers under the same parameter budget . table 7 shows the results . for example , when both dcgcn1 and dcgcn2 are limited to 10 . 9m parameters , dcgcn2 obtains 22 . 2 bleu points , which is higher than dcgcn1 ( 20 . 9 ) . similarly , when dcgcn3 and dcgcn4 contain 18 . 6m and 18 . 4m parameters . dcgcn4 outperforms dcgcn3 by 1 bleu point with a slightly smaller model . in general , we found when the parameter budget is the same , deeper dcgcn models can obtain better results than the shallower ones .
table 8 shows the ablation study of the level of density of our model dcgcn4 . we use dcgcns with 4 dense blocks as the full model . then we remove dense connections gradually from the last block to the first block . in general , the performance of the model drops substantially as we remove more dense connections until it cannot converge without dense connections . the full model gives 25 . 5 bleu points on the amr15 dev set . after removing the dense connections in the last block , the bleu score becomes 24 . 8 . without using the dense connections in the last two blocks , the score drops to 23 . 8 . furthermore , excluding the dense connections in the last three blocks only gives 23 . 2 bleu points . although these four models have the same number of layers , dense connections allow the model to achieve much better performance . if all the dense connections are not considered , the model does not coverage at all . these results indicate dense connections do play a significant role in our model .
table 9 shows the results . for the encoder , we find that the linear combination and the global node have more contributions in terms of b / c scores . the results drop by 2 / 2 . 2 and 1 . 3 / 1 . 2 points respectively after removing them . without these two components , our model gives a bleu score of 22 . 6 , which is still better than the best gcn + rc model ( 21 . 1 ) and the best gcn + rc + la model ( 22 . 1 ) . adding either the global node or the linear combination improves the baseline models with only dense connections . this suggests that enriching input graphs with the global node and including the linear combination can facilitate gcns to learn better information aggregations , producing more expressive graph representations . results also show the linear combination is more effective than the global node . considering them together further enhances the model performance . after removing the graph attention module , our model gives 24 . 9 bleu points . similarly , excluding the direction aggregation module leads to a performance drop to 24 . 6 bleu points . the coverage mechanism is also effective in our models . without the coverage mechanism , the result drops by 1 . 7 / 2 . 4 points for b / c scores .
to verify the effectiveness of our initialization strategy empirically , we evaluate it with the same experimental setup as described in section 4 . the only difference is the initialization strategy , where we include glorot initialization ( glorot & bengio , 2010 ) and the standard initialization from ( 0 , 0 . 1 ) . table 7 shows the results on the probing tasks . while glorot achieves slightly better results on bshift and topconst , cmow ' s ability to memorize word content is improved by a wide margin by our initialization strategy .
we have trained five different models : cbow and cmow with d = 20 and d = 28 , which lead to 400 - dimensional and 784 - dimensional word embeddings , respectively . we also trained the hybrid cbow - cmow model with d = 20 for each component , so that the total model has 800 parameters per word in the lookup tables . we report the results of two more models : h - cbow is the 400 - dimensional cbow component trained in hybrid and h - cmow is the respective cmow component . below , we compare the 800 - dimensional hybrid method to the 784 - dimensional cbow and cmow models . considering the linguistic probing tasks ( see table 1 ) , cbow and cmow show complementary results . while cbow yields the highest performance at word content memorization , cmow outperforms cbow at all other tasks . most improvements vary between 1 - 3 percentage points . the difference is approximately 8 points for coordinv and length , and even 21 points for bshift . the hybrid model yields scores close to or even above the better model of the two on all tasks . in terms of relative numbers , the hybrid model improves upon cbow in all probing tasks but wc and somo . the relative improvement averaged over all tasks is 8 % . compared to cmow , the hybrid model shows rather small differences . the largest loss is by 4 % on the coordinv task . however , due to the large gain in wc ( 20 . 9 % ) , the overall average gain is still 1 . 6 % . we now compare the jointly trained h - cmow and h - cbow with their separately trained 400dimensional counterparts . we observe that cmow loses most of its ability to memorize word content , while cbow shows a slight gain . on the other side , h - cmow shows , among others , improvements at bshift . regarding the probing tasks , we
table 2 shows the scores from the supervised downstream tasks . comparing the 784 - dimensional models , again , cbow and cmow seem to complement each other . this time , however , cbow has the upperhand , matching or outperforming cmow on all supervised downstream tasks except trec by up to 4 points . on the trec task , on the other hand , cmow outperforms cbow by 2 . 5 points . our jointly trained model is not more than 0 . 8 points below the better one of cbow and cmow on any of the considered supervised downstream tasks . on 7 out of 11 supervised tasks , the joint model even improves upon the better model , and on sst2 , sst5 , and mrpc the difference is more than 1 point . the average relative improvement over all tasks is 1 . 2 % . our cmow model produces sentence embeddings that are approximately at the level of fast sent ( hill et al . , 2016 ) . thus , cmow is a reasonable choice as a sentence encoder . observe that cmow embeddings better encode the linguistic propcmow gets reasonably close to cbow on some downstream tasks . however , cmow does not in general supersede cbow embeddings .
regarding the unsupervised downstream tasks ( table 3 ) , cbow is clearly superior to cmow on all datasets by wide margins . for example , on sts13 , cbow ' s score is 50 % higher . the hybrid model is able to repair this deficit , reducing the difference to 8 % . it even outperforms cbow on two of the tasks , and yields a slight improvement of 0 . 5 % on average over all unsupervised downstream tasks . however , the variance in relative performance is notably larger than on the supervised downstream tasks .
the success of our training schema for the cmow model are two changes to the original word2vec training . first , our initialization strategy improved the downstream performance by 2 . 8 % compared to glorot initialization .
alization strategy improved the downstream performance by 2 . 8 % compared secondly , by choosing the target word of the objective at random , the perfor mance of cmow on downstream tasks improved by 20 . 8 % on average . and on all unsupervised downstream tasks
to test the effectiveness of this modified objective , we evaluate it with the same experimental setup as described in section 4 . table 4 lists the results on the linguistic probing tasks . cmow - c and cbow - c refer to the models where the center word is used as the target . cmow - r and cbow - r refer to the models where the target word is sampled randomly . while cmow - r and cmow - c perform comparably on most probing tasks , cmow - c yields 5 points lower scores on wordcontent and bigramshift .
consequently , cmow - r also outperforms cmow - c on 10 out of 11 supervised downstream tasks on average over all downstream tasks , the relative improvement is 20 . 8 % . scores on downstream tasks increase on some tasks and decrease on others . the differences ar miniscule . on average over all 16 downstream tasks , cbow - r scores 0 . 1 % lower than cbow - c . for cbow , the
in table 3 we classified errors according to named entity types per is the easiest type for all systems . even name matching , without any learning , can correctly predict in half of the cases . for loc , it turns out that candidate selection is a bottleneck : when candidate selection was flawless , the models made only about 12 % errors , down from about 57 % . for misc a similar conclusion can be drawn .
table 2 shows results on the test set . ' name matching ' is far behind the two models . mil - nd achieves higher precision , recall , and f1 than mil , using its confidence at test time ( τ mil - nd , ' all ' setting ) was also beneficial in terms of precision and f1 ( it cannot possibly increase recall ) . because all the test data points are valid for the ' in e + ' setting , using the nd classifier had a slight negative effect on f1 . mil - nd significantly outperforms mil : the 95 % confidence intervals for them do not overlap . however , this is not the case for mil - nd and τ mil - nd .
we perform an entailment experiment using bert ( devlin et al . , 2019 ) fine - tuned on the multinli dataset ( williams et al . , 2018 ) as a nli model . we are interested in exploring whether a generated sentence ( hypothesis ) is semantically entailed by the reference sentence ( premise ) . in a related text generation task , falke et al . ( 2019 ) employ nli models to rerank alternative predicted abstractive summaries . table 6 shows the average probabilities for entailment , contradiction and neutral classes on the ldc2017t10 test set . all g2s models have higher entailment compared to s2s . g2s - ggnn has 33 . 5 % and 5 . 2 % better entailment performances than s2s , when ref entails gen and gen entails ref , respectively . g2s models also generate sentences that contradict the reference sentences less . this suggests that our models are capable of capturing better semantic information from the graph generating outputs semantically related to the reference sentences .
table 2 shows the comparison between the proposed models , the baseline and other neural models on the test set of the two datasets . for both datasets , our approach substantially outperforms the baselines . in ldc2015e86 , g2s - ggnn achieves a bleu score of 24 . 32 , 4 . 46 % higher than song et al . ( 2018 ) , who also use the copy mechanism . this indicates that our architecture can learn to generate better signals for text generation . on the same dataset , we have competitive results to damonte and cohen ( 2019 ) . however , we do not rely on preprocessing anonymisation not to lose semantic signals . in ldc2017t10 , g2s - ggnn achieves a bleu score of 27 . 87 , which is 3 . 33 points higher than damonte and cohen ( 2019 ) , a state - of - the - art model that does not employ external information . we also have competitive results to guo et al . ( 2019 ) , a very recent state - of - the - art model . we also outperform cao and clark ( 2019 ) improving bleu scores by 3 . 48 % and 4 . 00 % , in ldc2015e86 and ldc2017t10 , respectively . in contrast to their work , we do not rely on ( i ) leveraging supplementary syntactic information and ( ii ) we do not require an anonymization preprocessing step . g2s - gin and g2s - gat have comparable performance on both datasets . interestingly , g2s - ggnn has better performance among our models . this suggests that graph encoders based on gating mechanisms are very effective in text generation models . we hypothesize that the gating mechanism can better capture longdistance dependencies between nodes far apart in the graph .
we follow the method of konstas et al . ( 2017 ) , which is fine - tuning the model on the ldc2015e86 training set after every epoch of pretraining on the gigaword data . g2s - ggnn outperforms others with the same amount of gigaword sentences ( 200k ) , achieving a 32 . 23 bleu score , as shown in table 3 . the results demonstrate that pretraining on automatically generated amr graphs enhances the performance of our model .
in table 4 , we report the results of an ablation study on the impact of each component of our model on the development set of ldc2017t10 dataset by removing the graph encoders . we also report the number of parameters ( including embeddings ) used in each model . the first thing we notice is the huge increase in metric scores ( 17 % in bleu ) when applying the graph encoder layer , as the neural model receives signals regarding the graph structure of the input . the dual representation helps the model with a different view of the graph , increasing bleu and meteor scores by 1 . 04 and 0 . 68 points , respectively . the complete model has slightly more parameters than the model without graph encoders ( 57 . 6m vs 61 . 7m ) .
table 5 shows meteor5 scores for the ldc2017t10 dataset . the performances of all models decrease as the diameters of the graphs increase . g2s - ggnn has a 17 . 9 % higher meteor score in graphs with a diameter of at most 7 compared to graphs with diameters higher than 13 . this is expected as encoding a bigger graph ( containing more information ) is harder than encoding smaller graphs . since the models have fewer examples of bigger graphs to learn from , this also leads to worse performance when handling graphs with higher diameters . we also investigate the performance with respect to the sentence length . the models have better results when handling sentences with 20 or fewer tokens . longer sentences pose additional challenges to the models . g2s - gin has a better performance in handling graphs with node out - degrees higher than 9 . this indicates that gins can be employed in tasks where the distribution of node degrees has a long tail . surprisingly , s2s has a better performance than g2s - ggnn and g2s - gat when handling graphs that contain high degree nodes .
we also evaluate the semantic adequacy of our model ( how well does the generated output match the input ? ) by comparing the number of added and missing tokens that occur in the generated versus reference sentences ( gold ) . as shown in table 8 , g2s approaches outperform the s2s baseline . g2s - gin is closest to gold with respect to both metrics suggesting that this model is better able to generate novel words to construct the sentence and captures a larger range of concepts from the input amr graph , covering
we trained systems using a smaller data size ( 200k sentences ) , the results are shown in table 4 . we observe a variance in classifier accuracy of 1 - 2 % , based on target language , this is true for both pos and sem tagging .
we consider two baselines : most frequent tag ( mft ) for each word according to the training set ( with the global majority tag for unseen words ) ; and unsupervised word embeddings ( unsupemb ) as features for the classifier , we also report an upper bound of directly training an encoderdecoder on word - tag sequences ( word2tag ) , table 2 shows baseline and upper bound results . the unsupemb baseline performs rather poorly on both pos and sem tagging . nmt word embeddings ( table 3 , rows with k = 0 ) perform slightly better , the results are still below the most frequent tag baseline ( mft ) , this is above the unsupemb baseline but only on par with the mft baseline ( table 2 ) . the results are also far below the word2tag upper bound ( table 2 ) . which is far above the unsupemb and mft baselines . while these results are below the oracle word2tag results ( table 2 ) ,
nmt word embeddings ( table 3 , rows with k = 0 ) perform slightly better , table 3 summarizes the results of training classifiers to predict pos and sem tags using features extracted from different encoding layers of 4 layered nmt systems . 3 in the pos tagging results ( first block ) , as the representations move above layer 0 , performance jumps to around 91 – 92 % . this is above the unsupemb baseline but only on par with the mft baseline ( table 2 ) . the results are also far below the word2tag upper bound ( table 2 ) . comparing layers 1 through 4 , we see that in 3 / 5 target languages ( ar , ru , zh ) , pos tagging accuracy peaks at layer 1 and does not improve at higher layers , with some drops at layers 2 and 3 . in 2 / 5 cases ( es , fr ) the performance is higher at layer 4 . turning to sem tagging ( table 3 , second block ) , representations from layers 1 through 4 boost the performance to around 87 - 88 % , which is far above the unsupemb and mft baselines . while these results are below the oracle word2tag results ( table 2 ) , going beyond the 1st encoding layer , representations from the 2nd and 3rd layers do not consistently improve semantic tagging performance . however , representations from the 4th layer lead to significant improvement with all target languages except for chinese . we found that en - en encoder - decoders ( that is , english autoencoders ) produce poor representations for pos and sem tagging ( last column in table 3 ) . this is especially true with higher layer representations ( e . g . around 5 % below the mt models using representations from layer 4 ) . in contrast , the autoencoder has excellent sentence recreation capabilities ( 96 . 6 bleu ) . table 3 also shows results using features obtained by training nmt
improvements in both translation ( + 1 - 2 bleu ) and sem tagging quality ( + 3 - 4 % accuracy ) , across the board , when using a bidirectional encoder . some of our bidirectional models obtain 92 - 93 % accuracy . we observed similar improvements on pos tagging . comparing pos and sem tagging ( table 5 ) , we note that higher layer representations improve sem tagging , while pos tagging peaks at layer 1 . we noticed small but consistent improvements in both translation ( + 0 . 9 bleu ) and pos and sem tagging ( up to + 0 . 6 % accuracy ) when using features extracted from an nmt model trained with residual connections ( table 5 ) . we also observe similar trends as before : pos tagging does not benefit from features from the upper layers , while sem tagging improves with layer 4 representations .
table 8 summarize the training accuracies of the attacker network . the mention / race task achieves the highest score of 64 . 3 % whereas the mention / gender task achieves the lowest 58 . 1 % .
the results in table 1 indicate that the classifiers achieve reasonable accuracies for the main tasks . the protected attributes , race is highly predictable ( 83 . 9 % ) while age and gender can also be recovered at above 64 % accuracy .
this experiment suggests an upper bound on the amount of leakage of protected attributes when we do not actively attempt to prevent it . the balanced section in table 2 summarizes the validation - set accuracies . while the numbers are lower than when training directly ( table 1 ) , they are still high enough to extract meaningful and possibly highly sensitive information ( e . g . dial race direct prediction is 83 . 9 % while dial race leakage on the balanced sentiment task is 64 . 5 % ) . we simulate this more realistic scenario by constructing unbalanced datasets in which the main tasks ( sentiment / mention ) remain balanced but the protected class proportions within each main class are not , as demonstrated in figure 1b . we then follow the leakage experiment on the unbalanced datasets . the attacker is trained and tested on a balanced dataset . otherwise , the attacker can perform quite well on the male / female task simply by learning to predict sentiment , which does not reflect leakage of gender data to the representation . when training the attacker on balanced data , its decisions cannot rely on the sentiment information encoded in the vectors , and must look for encoded information about the protected attributes . the results in table 2 indicate that both task accuracy and attribute leakage are stronger in the unbalanced case .
however , training the attacker network on the resulting encoder vectors reveals a different story . for example , when considering the encoder after 50 training epochs ( adversary accuracy of 49 . 0 % ) , the attacker reaches 56 . 0 % accuracy : substantially higher than the adversarial ' s success rate , despite sharing the exact same architecture , and being trained and tested on the exact same dataset . table 3 summarizes the attacker ' s recovery rate on the adversarialy - trained encoders for the different settings . in all cases , the adversarial ' s success rate is around 50 % , while the attacker ' s rate is substantially higher .
we compare encoders leaky - emb and leaky - rnn to gauge which module has a greater contribution to the data leakage . table 6 summarize the results , implying that the leakage is caused mainly by the rnn , and less by the embedding matrix .
table 5 shows the test perplexity of different models . 10 in this task , lrn significantly outperforms gru , atr and sru , and achieves near the same perplexity as lstm .
table 1 shows the test accuracy and training time of different models . our implementation outperforms the original model where rockt ¨ aschel et al . ( 2016 ) report an accuracy of 83 . 50 . overall results show that lrn achieves competitive performance but consumes the least training time . although lstm and gru outperform lrn by 0 . 3 ∼ 0 . 9 in terms of accuracy , these recurrent units sacrifice running efficiency ( about 7 % ∼ 48 % ) depending on whether ln and bert are applied . no significant performance difference is observed between sru and lrn , but lrn has fewer model parameters and shows a speedup over sru of 8 % ∼ 21 % . however , for lstm , gru and atr , ln results in significant computational overhead ( about 27 % ∼ 71 % ) . in contrast , quasi recurrent models like sru and lrn only suffer a marginal speed decrease . results with bert show that contextual information is valuable for performance improvement . lrn obtains additional 4 percentage points gain with bert and reaches an accuracy of around 89 . 9 . in addition , although the introduction of bert brings in heavy matrix computation , the benefits from lrn do not disappear . lrn is still the fastest model , outperforming other recurrent units by 8 % ∼ 27 % .
table 2 summarizes the classification results . lrn achieves comparable classification performance against atr and sru , but slightly underperforms lstm and gru ( - 0 . 45 ∼ - 1 . 22 ) . lrn accelerates the training over lstm and sru by about 20 % ,
the results in table 3 show that translation quality of lrn is slightly worse than that of gru ( - 0 . 02 bleu ) . however , olrn yields the best bleu score of 26 . 73 , outperforming gru ( + 0 . 45 bleu ) . in addition , the training time results in table 3 confirm the computational advantage of lrn over all other recurrent units , where lrn speeds up over atr and sru by approximately 25 % . the recurrent unit with the least computation operations , i . e . atr , becomes the fastest . still , both lrn and olrn translate sentences faster than sru ( + 15 % / + 6 % ) .
table 4 lists the em / f1 score of different models . in this task , lrn outperforms atr and sru in terms of both em and f1 score . after integrating elmo for contextual modeling , the performance of lrn reaches the best ( 76 . 1 em and 83 . 83 f1 ) , beating both gru and lstm ( + 0 . 33em , + 0 . 71f1 ) .
as shown in table 6 , the performance of lrn matches that of atr and sru , though lstm and gru operate better ( + 1 . 05 and + 0 . 79 ) .
we experiment with snli and ptb tasks . results in table 7 show that although the accuracy on snli is acceptable , glrn and elrn perform significantly worse on the ptb task .
bleu - 2 , bleu - 4 , rouge - 2 recall , and meteor are reported in table 3 for both setups . under system setup , our model candela statistically significantly outperforms all comparisons and the retrieval model in all metrics , based on a randomization test ( noreen , 1989 ) ( p < . 0005 ) . furthermore , our model generates longer sentences whose lengths are comparable with human arguments , both with about 22 words per sentence . this also results in longer arguments . under oracle setup , all models are notably improved due to the higher quality of reranked passages , and our model achieves statistically significantly better bleu scores . interestingly , we observe a decrease of rouge and meteor , but a marginal increase of bleu - 2 by removing passages from our model input . this could be because the passages introduce divergent content , albeit probably on - topic , that cannot be captured by bleu .
inter - annotator agreement scores ( krippendorff ' s α ) of 0 . 44 , 0 . 58 , 0 . 49 are achieved for the three aspects , implying general consensus to intermediate agreement . our system obtains the highest appropriateness and content richness among all automatic systems . this confirms the previous observation that our model produces more informative argument than other neural models . seq2seqaug has a marginally better grammaticality score , likely due to the fact that our arguments are longer , and tend to contain less fluent generation towards the end . furthermore , we see that human arguments are
in this first experiment we reduce the vocabulary to the top 1 , 000 terms with the highest number of contexts . table 3 presents the general overview of these values for each method in each corpus , where the highest values are presented in bold . analyzing table 3 , we can observe that all values of precision using the portuguese corpora have higher scores when compared with the english corpora . a higher number of terms associated in hypernyms tends to increase the precision . another aspect to be considered is the fact that as onto . pt is automatically constructed , there are relations that would not exist if it was manually constructed or revised . as we can observe in table 3 , patt has the best values of precision for the english corpora while docsub has the best values for the portuguese corpora . tf has the best values of recall and f - measure for all corpora but the english version of ted talks which has in df the best value of recall and in docsub the best value of f - measure . it was expected quite similar values of precision , recall and f - measure between tf and df using the europarl corpora since the size of each document was set to the size of the phrase because europarl does not have document borders . this value differs when a term appears more than once in a phrase , and thus , having a higher value of tf than df . in some cases it seems to make difference in results , e . g . , europarl in portuguese which increased the precision from p = 0 . 5984 in df to p = 0 . 6109 in tf , as well as the recall from r = 0 . 5184 in df to r = 0 . 6727 in tf , resulting in an increase of f - measure from f = 0 . 5555 in df to f = 0 . 6403 in tf . when comparing df
observing results from hclust , which obtained the best f - measure in a cluster containing 1 , 000 terms ( the f - measure was still rising ) , we decide to perform a second experiment , increasing the number of terms , and consequently clusters . table 4 presents the values of precision and recall for all models using a vocabulary containing up to 10 , 000 words , where docsub and hclust contain results when the best f - measure was achieved , and patt consider all patterns with the limited number of words . as we can see , values of precision were lower for most methods , with exception of patt and docsub , which increased for most corpora . when increasing the number of terms to 10 , 000 , the docsub models using europarl corpora performed better than when using ted talks corpora . although decreasing the values of precision , tf and df increased the values of recall , but decreasing the values of f - measure . as occurred in the experiment using the top 1 , 000 words , this experiment also kept tf with the highest values of f - measure for most methods . tf and df achieved almost the same values of precision , recall and f - measure using the english corpora , achieving the same value of precision ( p = 0 . 0150 ) and f - measure ( f = 0 . 0293 ) when using the europarl corpus in english . when comparing df with hclust , it seems a good approach in english to verify the hierarchical relation only for terms that are semantically related instead of considering all terms . the lowest values of precision are achieved by dsim model , and the lowest recalls are obtained by hclust and patt models .
table 5 presents the values of precision , recall and f - measure for the methods in all corpora . the filtering on multiple hypernyms is applied in relations extracted using 1 , 000 terms in the dictionary . analyzing table 5 we observe that patt achieves again the best precision values for the english corpora . on the other hand , choosing the best hypernym worked very well for docsub which obtained the best precision for the portuguese corpora . as filtering out multiple hypernyms might remove also correct relations , the recall values for all corpora are very low . the values of precision increased for most corpora of the patt and docsub models . comparing the values achieved by hclust using 1 , 000 terms and the ones obtained when reducing to one parent , we can see that they are almost the same . only ted talks corpora obtained a decrease in precision ( from p = 0 . 0664 to p = 0 . 0661 in english and from p = 0 . 5656 to p = 0 . 5295 in portuguese ) . increasing the number of terms form 1 , 000 to 10 , 000 only increased the recall in tf and df models .
using the direct graph with transitive reduction for each model , we generated the metrics presented in table 6 . the results are generated for models using the top 1 , 000 terms of each corpus in english generated for the automatic evaluation , i . e . , models using nouns instead of noun phrases . as we can observe in table 6 , limiting the number of terms to 1 , 000 , patt and docsub do not to generate relations for all terms . patt model could not generate relations for all terms because terms must to be in a pattern in order to have their taxonomic relation identified . for example , using relations generated by tf model using the europarl corpus , we can understand the maxdepth as having 789 terms with different values of term frequency , while having 211 that share the same value of term frequency with other terms . using the slqs model , we can understand that 902 terms share different values of entropy , while 98 share the same value with other terms .
table 7 contains the results for each metric after applying the transitive reduction for relations generated by models using the top 1 , 000 terms of each corpus in portuguese . the results for the portuguese corpora are quite similar to the ones generated by the english corpora , having terms without relations in patt and docsub , and dsim , slqs , tf and df generating deep taxonomies , affirming the characteristics of each method . for portuguese , the number of relations found by patt model using the ted talks corpus were smaller than the one found using the english corpus , impacting the maximum depth . on the other hand , the number of siblings for a term was greater .
table 1 shows the results with different implementations in p2 , i . e . , question type , answer score sampling , and hidden dictionary learning . overall , all of the implementations can improve the performances of base models . specifically , the implementations of p2 can further boost performance by at most 11 . 75 % via hidden dictionary learning .
table 2 shows the results about applying our principles on four different models ( i . e . , lf , hciae , coatt and rva ) . in general , both of our principles can improve all the models in any ablative condition ( i . e . , p1 , p2 , p1 + p2 ) . note that the effectiveness of p1 and p2 are additive , which means combining p1 and p2 performs the best .
we use the representations in the 9 - th bert layer for fair comparison of bertscore and moverscore and show results on the machine translation task in table 5 . moverscore outperforms both asymmetric hmd factors , while if they are combined via harmonic mean , bertscore is on par with moverscore . we also observe that wmd - bigrams slightly outperforms wmd - unigrams on 3 out of 4 language pairs .
table 1 : in all language pairs , the best correlation is achieved by our word mover metrics that use a bert pretrained on mnli as the embedding generator and pmeans to aggregate the embeddings from different bert layers , i . e . , wmd - 1 / 2 + bert + mnli + pmeans . note that our unsupervised word mover metrics even outperforms ruse , a supervised metric . we also find that our word mover metrics outperforms the sentence mover .
tables 3 : interestingly , no metric produces an even moderate correlation with human judgments , including our own . however , best correlation is still achieved by our word mover metrics combining contextualized representations .
table 4 : word mover metrics outperform all baselines except for the supervised metric leic , which uses more information by considering both images and texts .
that under similar acc , m2 has much better semantic similarity for both yelp and literature . in fact , cyclic consistency loss proves to be the strongest driver of semantic preservation across all of our model configurations . the other losses do not constrain the semantic relationship across style transfer , so we include the cyclic loss in m3 to m7 . when comparing between m2 and m3 , between m4 and m5 , and between m6 and m7 , we find that the addition of the language modeling loss reduces pp , sometimes at a slight cost of semantic preservation .
overall , the results show the same trends as our automatic metrics . for example , on yelp , large differences in human judgments of semantic preservation ( m2 > m0 , m7 > m0 , m7 > m2 ) also show the largest differences in sim , while m6 and m7 have very similar human judgments and very similar sim scores .
we describe a human sentence - level validation of our metrics in table 5 . to validate acc , human annotators were asked to judge the style of 100 transferred sentences we then compute the percentage of machine and human judgments that match . we validate sim and pp by computing sentence - level spearman ' s ρ between the metric and human judgments from table 5 , all validations show strong correlations on the yelp dataset and reasonable correlations on literature .
under similar acc , m2 has much better semantic similarity for both yelp and literature . in fact , cyclic consistency loss proves to be the strongest driver of semantic preservation across all of our model configurations . the other losses do not constrain the semantic relationship across style transfer , so we include the cyclic loss in m3 to m7 . table 2 shows that the model with paraphrase loss ( m1 ) slightly improves sim over m0 on both datasets under similar acc . for yelp , m1 has better acc and pp than m0 at comparable semantic similarity . so , when used alone , the paraphrase loss helps . however , when combined with other losses ( e . g . , compare m2 to m4 ) , its benefits are mixed . when comparing between m2 and m3 , between m4 and m5 , and between m6 and m7 , we find that the addition of the language modeling loss reduces pp , sometimes at a slight cost of semantic preservation .
bleu scores and post - transfer accuracies are shown in table 6 . the most striking result is that untransferred sentences have the highest bleu score by a large margin , suggesting that prior work for this task has not yet eclipsed the trivial baseline of returning the input sentence . however , at similar levels of acc , our models have higher bleu scores than prior work . we additionally find that supervised bleu shows a trade - off with acc : for a single model type , higher acc generally corresponds to lower bleu .
for each class , we measured the disfluency detection recall ( relative frequency of reparandum tokens that were predicted correctly ) , as well as the percentage of tokens associated with each class . the results in table 2 confirm that error rates are higher for restarts , longer rephrasings , and complex disfluencies .
table 3 breaks down performance for different lengths and word class to explore this difference . we found that rephrase disfluencies that contain content words are harder for the model to detect , compared to rephrases with function words only , and error increases for longer disfluencies .
our experiments evaluate the use of innovations with two popular multimodal fusion approaches : early fusion and late fusion . our baselines include models with text - only , prosody cues only ( raw ) , and innovation features only as inputs . since innovations require both text and raw prosodic cues , this baseline is multimodal . in addition , for the late fusion experiments , we show the optimal value of α , the interpolation weight from equation 5 . we found that innovations are helpful in both early and late fusion frameworks , while late fusion performs better on average . the interpolation weight α for the late fusion experiments is high when innovations are used , which further indicates that innovation features are useful in overall prediction . interestingly , innovation features alone perform surprisingly well .
table 2 shows a comparison of the detection performance . as for the micro f1 evaluation metric , our model achieves the highest performance ( 83 . 54 % ) on the fnc - 1 testing subset .
the deep network based neuraldater model in ( vashishth et al . , 2018 ) outperforms previous feature engi neered ( chambers , 2012 ) and statistical methods ( kotsakos et al . , 2014 ) by a large margin . we observe a similar trend in our case . compared to the state - of - the - art model neuraldater , we gain , on an average , a 3 . 7 % boost in accuracy on both the datasets ( table 2 ) .
attentive graph convolution ( section 4 . 2 . 2 ) proves to be effective for oe - gcn , giving a 2 % accuracy improvement over non - attentive t - gcn of neuraldater ( table 3 ) . similarly the efficacy of word level attention is also prominent from table 3 .
table 2 illustrates the performance ( f1 scores ) of jrnn ( nguyen et al . , 2016 ) , dmcnn ( chen the two baseline model embedet al . , 2015 ) , ding + t and cnn in chen et al . ( 2015 ) and our framework in trigger classification subtask and argument role labeling subatsk . we can see that our framework significantly outperforms all the other methods , especially in trigger classification subtask . in the 1 / n data split of triggers , our framework is 7 . 9 % better than the jrnn ,
table 1 shows the overall performance comparing to the above state - of - the - art methods with golden - standard entities . from the table , we can see that our jmee framework achieves the best f1 scores for both trigger classification and argumentrelated subtasks among all the compared methods . there is a significant gain with the trigger classification and argument role labeling performances , which is 2 % higher over the best - reported models .
the results of the different models are presented in table 3 . for each model we report both perplexity and accuracy ( except for discriminative training , where perplexity is not valid ) , where each of them is reported according to the best performing model on that measure ( on the dev set ) . we also report the wer of all models , which correlates perfectly with the accuracy measure . extending the vocabulary without training those additional words , results in a 2 . 37 - points loss on the perplexity measure , while our evaluation metric ( accuracy ) stays essentially the same . the finetuned - lm baseline is the strongest baseline , outperforming all others with an accuracy of 65 . 4 % . similarly , when using discriminative trainthe fine - tuned - discriminative model ing , outperforms the cs - only - discriminative model . note that using discriminative training , even with no additional monolingual data , leads to better performance than that of the best language model : the cs - only - discriminative model achieves an accuracy of 70 . 5 % , 5 . 1 points more than the accuracy of the fine - tuned - lm model . we gain further improvement by adding monolingual data and get an even higher accuracy of 75 . 5 % , which is 10 . 1 points higher than the best language model .
table 4 depicts the results when using subsets of the cs training data with discriminative training . the less code - switching data we use , the more the effect of using the monolingual data is significant : we gain 8 . 8 , 6 . 5 , 4 . 2 and 5 more accuracy points with 25 % , 50 % , 75 % and 100 % of the data , respectively . in the case of 25 % of the data , the fine - tuned - discriminative model improves over cs - only - discriminative by 17 relative percents .
table 5 breaks down the results of the different models according to two conditions : when the gold sentence is code - switched , and when the gold sentence is monolingual . the fine - tuneddiscriminative model is able to prioritize the gold sentence better than all other models , under both conditions . the improvement we get is most significant when the gold sentence is cs : in those cases we get a dramatic improvement of 27 . 73 accuracy points ( a relative improvement of 58 % ) .
table 7 shows that compared to a baseline without gaze features , the results improve by 3 % f1 - score .
we achieve a minor , but nonetheless significant improvement ( shown in table 5 ) , which strongly supports the generalizability effect of the typeaggregated features on unseen data .
table 1 shows that our proposed token level embedding scheme ontolstm - pp outperforms the better variant of our baseline lstm - pp ( with glove - retro intialization ) by an absolute accuracy difference of 4 . 9 % , or a relative error reduction of 32 % . ontolstm - pp also outperforms hpcd ( full ) , the previous best result on this dataset . initializing the word embeddings with gloveretro ( which uses wordnet as described in faruqui et al . ( 2015 ) ) instead of glove amounts to a small improvement , compared to the improvements obtained using ontolstm - pp .
table 2 shows the effect of using the pp attachment predictions as features within a dependency parser . we note there is a relatively small difference in unlabeled attachment accuracy for all dependencies ( not only pp attachments ) , even when gold pp attachments are used as additional features to the parser . however , when gold pp attachment are used , we note a large potential improve ment of 10 . 46 points in pp attachment accuracies ( between the ppa accuracy for rbg and rbg + oracle pp ) , which confirms that adding pp predictions as features is an effective approach . our proposed model rbg + ontolstm - pp recovers 15 % of this potential improvement , while rbg + hpcd ( full ) recovers 10 % , for example , the unlabeled attachment score ( uas ) of the baselines rbg and rbg + hpcd ( full ) are 94 . 17 and 94 . 19 , respectively , in table 2 , compared to 93 . 96 and 94 . 05 , respectively , in belinkov et al . ( 2014 ) .
the second row in table 3 shows the test accuracy of a system trained without sense priors and the third row shows the effect of making the token representations context - insensitive by giving a similar attention score to all related concepts , essentially making them type level representations , but still grounded in wordnet .
in our first series of experiments , we observed that domain - tuning is very important when using marian . table 2 shows the scores on development data . we also tried decoding with an ensemble of three independent runs , which also pushed the performance a bit .
table 3 lists the scores we obtained on development data . for marian amun , the effect is negligible as we can see in table 3 . for the transformer , domain labels had little effect on bleu but were clearly beneficial according to chrf - 1 . 0 .
table 4 summarizes the scores on the three development test sets for english - french and englishgerman . we can see that the dual attention model does not work at all and the scores slightly drop . the concatenation approach works better however , the improvements are small if any
table 5 shows the bleu scores for this configuration with different ways of integrating the visual features . the results are inconclusive . the ranking according to chrf - 1 . 0 was not any clearer .
table 6 shows results of ablation experiments removing or modifying one component or data choice at a time , and results when using ensemble decoding . using ensemble decoding gave a consistent but small improvement . multi - lingual models were clearly better than mono - lingual models . for french , 6m sentences of subtitle data gave worse results than 3m . it appears that the output vocabulary was reduced back towards the vocabulary seen in the multi - modal training set . when the experiment was repeated so that the finetuning phase included the text - only data , the performance returned to approximately the same level as without tuning ( + multi - modal finetune row in table 6 ) . bleu scores for french were surprisingly slightly improved by this procedure .
table 6 shows the metrics smt seems to retain the most lexical richness according to the ld metrics we used ( ttr , yule ' s and mtld ) .
number of parallel sentences in the train , test and development splits for the language pairs we used . we used + / - 2m sentence pairs from the europarl corpora for each of the language pairs . split the data into train , test and development sets , details on the different datasets can be found in table 1 . we chose to include large quantities of data in our test sets
table 2 ( first two columns ) shows the training vocabularies for the source and target sides . table 3 presents sizes for the rnn , smt and transformer systems . this table clearly shows how source and target vocabularies are comparable in the original datasets ,
we present bleu and ter for the rev systems in table 5 , while transformer models are the best ones according to the evaluation metrics ,
evaluating this speaker - invariant representation gave contradictory results , shown in table 2 : very good scores on paraphrase retrieval , but zero correlation with visual space .
table 1 shows the evaluation results on synthetic speech . representations learned by audio2vec and segmatch are compared to the performance of random vectors , mean mfcc vectors , as well as visually supervised representations ( vgs , model from chrupała et al . ( 2017 ) ) . audio2vec works better than chance and mean mfcc on paraphrase retrieval , but does not correlate with the visual space . segmatch works much better than audio2vec according to both criteria . it does not come close to vgs on paraphrase retrieval , but it does correlate with the visual modality even better .
using sift we observed substantial differences in the text generated by our fine - tuned decoder when trained with each of the different while the rnn primarily employs < unk > tokens or repeats previous words , the cnn masks out < unk > tokens using determiners or prepositions . in contrast , dan masks out punctuation and determiners using words indicative of the class label ( i . e . nouns , verbs , adjectives ) . we hypothesize that these patterns stem from the inductive biases of the classifiers . dan receives a stronger signal by repeating words with a higher sentiment value due to its averaging , while 1nltk ( loper and bird , 2002 ) was used for pos tagging . the cnn does not repeat words ( thus having the least amount of changes ) and removes uninformative words as its max - pooling layer selects only the most important ones . similarly , the gates of the lstm may allow the model to ignore the random and thus noisy < unk > embeddings , which enables it to use this token as a masking operation to ignore unimportant words . examples are in table 1 , results in 2 and 3 .
in order to identify differences , we conducted an automated study of the reconstructed text by inspecting changes in the proportion of part - ofspeech tags1 and an increase or decrease in word polarity for sentiment compared to the original input . to compare our abstractive with an extractive approach ( rnp ; lei et al . , 2016 ) , we compute the overlap of retained terms in table 2 ( bottom row ) . we can see that the dan has the highest overlap , indicating that it retains words , while the cnn and rnn reformulate sentences . these scores highlight the differences of our approach , as our model does not solely extract indicative words , but reformulates the original sentence .
in order to automatically identify if sift retains the sentiment of the sentences , we analyze the output using sentiwordnet ( baccianella et al . , 2010 ) . by considering only adjectives , we obtain a measure of the positive and negative score for each sentence before and after fine - tuning . the difference of these scores averaged over all examples provides us with a sense of whether the fine - tuning increases the polarity of the sentences ( table 3 ) . we see a constant increase in sentiment value in both directions across all three models after finetuning demonstrating that the framework is able to pick up on words that are indicative of sentiment . this is especially true in the case of dan where we see a large increase as the decoder repeatedly predicts words having high sentiment value . overall , these results indicate that sift is able to highlight certain inductive biases of the model and is able to reformulate and amplify the meaning of the original text based on the classifier ' s preferences .
we compare the most frequent sift terms with the most indicative words w . r . t . a class using pmi with 100 smoothing , following gururangan et al . ( 2018 ) . we list the most frequently used words in table 4 . to understand how similar the sift terms are to the pmi terms we calculate the weighted kendall ' s tau correlation ( shieh , 1998 ) , which weights terms higher in the list as more important . in the case of high correlation , we hypothesize that the classifier has memorized the artifacts of the data set , which in turn sift has leveraged to " fool " the classifier . this " fooling " in the case of sentiment analysis is due to the terms being indicative of the respective class and having high sentiment ( cf . table 3 ) . for snli , we find that many of the top pmi and sift terms overlap , and slightly correlate ( 0 . 366 ) . we find terms ( as reported in appendix a2 ) , e . g . ' sleeping ' , ' cats ' , ' cat ' , that were identified as artifacts by gururangan et al . ( 2018 ) . in the pubmed task where the aim is to classify sentences as belonging to one of five classes — background , objective , methods , results , conclusions — the top terms in the setting where we change ground truth from " objective " to " conclusion " are intuitively relevant terms for that class . they do not , however , correlate with pmi , which might indicate that pretraining on large unlabelled data has enabled sift to capture these relations . overall , this shows that sift is able to identify both previously known as well as novel artifacts . in contrast to pmi , sift uncovers the propensities of the trained model and not only the data set , giving insight into what the model has actually encoded .
